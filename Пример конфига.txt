const byte unitTestConfig[] PROGMEM = { // тестовый конфиг в памяти

  // заголовок конфига
  CORE_HEADER1,
  CORE_HEADER2,
  CORE_HEADER3,

    //---------------------------------------
      DeviceIDRecord, // уникальный ID устройства в системе (0-255)
      1, // у нас устройство с адресом 1, адрес всегда доступен вызовом Core.DeviceID
    //---------------------------------------
      ClusterIDRecord, // уникальный ID кластера (0-255)
      2, // у нас кластер номер 2, номер кластера всегда доступен вызовом Core.ClusterID
    //---------------------------------------
      SensorRecord, // данные о датчике
      'B','H','1','7','5','0','-','1','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      BH1750, // датчик BH1750
      2, // длина данных
      0, // индекс I2C (0 - Wire, 1 - Wire1)
      BH1750Address1, // на первом адресе на шине I2C
    //---------------------------------------
      SensorRecord, // данные о датчике
      'B','H','1','7','5','0','-','2','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      BH1750, // датчик BH1750
      2, // длина данных
      0, // индекс I2C (0 - Wire, 1 - Wire1)
      BH1750Address2, // на втором адресе на шине I2C
    //---------------------------------------
    //TODO: ДЛЯ SI7021 СДЕЛАТЬ ВОЗМОЖНОСТЬ ИМЕТЬ ИХ НЕСКОЛЬКО НА ШИНЕ I2C !!!
      SensorRecord, // данные о датчике
      'S','I','7','0','2','1','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      Si7021, // датчик Si7021
      1,  // длина данных
      0, // индекс I2C (0 - Wire, 1 - Wire1)
    //---------------------------------------
      SensorRecord, // данные о датчике
      'D','H','T','2','1','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      DHT, // датчик DHT
      2, // длина данных
      DHT_2x, // тип датчика - DHT21
      5, // пин датчика - 5
    //---------------------------------------
      SensorRecord, // данные о датчике
      'R','T','C','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      DS3231, // датчик часов реального времени DS3231 на шине I2C
      1, // длина данных
      0, // индекс I2C (0 - Wire, 1 - Wire1)
    //---------------------------------------
      SensorRecord, // данные о датчике
      'R','T','C','T','e','m','p','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      DS3231Temperature, // температура с датчика часов реального времени DS3231 на шине I2C
      1, // длина данных
      0, // индекс I2C (0 - Wire, 1 - Wire1)
    //---------------------------------------
      SensorRecord, // данные о датчике
      'D', 'S', '1', '\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      DS18B20, // датчик DS18B20
      1, // длина данных
      6, // пин датчика - 6
    //---------------------------------------
      SensorRecord, // данные о датчике
      'D', 'S', '2', '\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      DS18B20, // датчик DS18B20
      1, // длина данных
      6, // пин датчика - 6
    //---------------------------------------
      SensorRecord, // данные о датчике
      'P','I','N','1','3','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      DigitalPortState, // состояние цифрового порта
      1, // длина данных
      13, // пин датчика - 13
    //---------------------------------------
      SensorRecord, // данные о датчике
      'A','1','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      AnalogPortState, // состояние аналогового порта
      1, // длина данных
      power_200, // пин датчика - power_200
    //---------------------------------------
      SensorRecord, // данные о датчике
      'A','2','\0', // набор байт, заканчивающийся нулём, содержащий мнемоническое имя датчика (для удобного обращения по имени)
      AnalogPortState, // состояние аналогового порта
      1, // длина данных
      power_3V3, // пин датчика - power_3V3
    //---------------------------------------
      SensorRecord, // данные о датчике
      '5', 'V', '\0', // даём датчику имя "5V"
      AnalogPortState, // состояние аналогового порта
      1, // длина данных
      power_5V0, // пин датчика - power_5V0
    //---------------------------------------
      SensorRecord, // данные о датчике
      'U', 'D', '\0', // даём датчику имя "UD"
      UserDataSensor, // пользовательские данные любого вида
      1, // длина данных
      2, // длина буфера, хранимого датчиком - 2 байта
    //---------------------------------------
      ESPSettingsRecord, // настройки ESP
      'E','S','P','\0',  // имя точки доступа (набор байт, заканчивающийся нулевым байтом)
      '1','2','3','4','5','6','7','8','\0', // пароль точки доступа (набор байт, заканчивающийся нулевым байтом - минимум 8 символов!)
      1, // флаг - коннектиться ли к роутеру (1 - коннектиться, 0 - не коннектиться)
      'F', 'l', 'y', '\0', // SSID роутера (набор байт, заканчивающийся нулевым байтом)
      'H', 't', 'R', 'j', '7', 'U', 'J', 'Q', '\0', // пароль роутера (набор байт, заканчивающийся нулевым байтом)
      12, // скорость работы с ESP (1 - 9600, 2 - 19200, 4 - 38400, 6 - 57600, 12 - 115200)
      1, // номер Serial, который используется для работы с ESP (1 - Serial1, 2 - Serial2, 3 - Serial3)
      0, // использовать ли пин пересброса питания при зависании ESP (0 - не использовать, 1 - использовать)
      0, // номер пина для пересброса питания ESP
      30, // кол-во секунд, по истечении которых модем считается зависшим (не пришёл ответ на команду)
      2, // сколько секунд держать питание выключенным при перезагрузке ESP, если он завис
      2, // сколько секунд ждать загрузки модема при инициализации/переинициализации
      1, // уровень для включения питания (1 - HIGH, 0 - LOW)       
    //---------------------------------------
      RS485SettingsRecord, // настройки RS-485
      6, // скорость работы с RS-485 (1 - 9600, 2 - 19200, 4 - 38400, 6 - 57600, 12 - 115200)      
      2, // номер Serial, который используется для работы с RS-485 (1 - Serial1, 2 - Serial2, 3 - Serial3)
      5, // пин управления приёмом-передачей MAX-485
      1, // в каком режиме мы работаем (1 - мастер, 0 - слейв). В режиме слейв модуль только слушает шину, ища известные пакеты. В режиме мастер - сам опрашивает шину на предмет получения показаний с датчиков
    //---------------------------------------
    /*
      RS485IncomingPacketRecord, // данные по входящему пакету по RS-485
      3, // длина заголовка
      '1', '2', '3', // байты заголовка пакета
      5, // длина данных пакета (БЕЗ ЗАГОЛОВКА)
      123, // внутренний идентификатор пакета
    //---------------------------------------    
      RS485IncomingPacketRecord, // данные по входящему пакету по RS-485
      2, // длина заголовка
      '9', '9', // байты заголовка пакета
      3, // длина данных пакета (БЕЗ ЗАГОЛОВКА)
      44, // внутренний идентификатор пакета
      */
    //---------------------------------------
      LoRaSettingsRecord, // данные по настройкам LoRa
      1, // частота работы с LoRa, Hz (1 - 433E6, 2 - 866E6, 3 - 915E6)
      10, // пин SS для LoRa
      0xFF, // пин RESET для LoRa (0xFF - не назначен)
      3, // пин DIO0 для LoRa (пин с прерываниями!!!)
      17, // мощность передатчика, dB (2-17)
      8, // ширина полосы пропускания сигнала, Hz (1 - 7.8E3, 2 - 10.4E3, 3 - 15.6E3, 4 - 20.8E3, 5 - 31.25E3, 6 - 41.7E3, 7 - 62.5E3, 8 - 125E3, 9 - 250E3)
      0, // использовать или нет CRC (0 - не использовать, 1 - использовать)
      1, // в каком режиме мы работаем (1 - мастер, 0 - слейв)
      5, // кол-во попыток ретрансмита пакета
      60, // частота отсылки данных с датчиков, секунд (до 255)
    //---------------------------------------
      FractDelimiterRecord, // // разделитель целой и дробной частей
      ',', // у нас этим разделителем будет запятая
    //---------------------------------------
      TemperatureUnitRecord, // // вид измеряемой температуры (цельсии - UnitCelsius или фаренгейты - UnitFahrenheit)
      UnitCelsius, // у нас будут цельсии
    //---------------------------------------
      SensorsUpdateIntervalRecord, // интервал опроса датчиков, в секундах
      5, // у нас будет 5 секунд между опросами
    //---------------------------------------
  
  // окончание конфига
  CORE_HEADER1
  
};